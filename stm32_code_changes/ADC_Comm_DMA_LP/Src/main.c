
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#ifndef WINDOWS_TESTING
#include "fatfs.h"
#else
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
typedef FILE FIL;
typedef uint32_t FATFS;
typedef uint32_t FRESULT;
#endif
#include "arm_math.h"
#include "optics.h"

#define SAMPLING_FREQ 2500.0f	//in kHz // Maybe 2222.2222f -> 20 MHz / (5 dummy cycles + 4 data cycles) (ADC)
#define FFT_RES (SAMPLING_FREQ/256)
#define OPTICS_FRAMESIZE 400
#define OPTICS_OVERLAP 100

// OPTICS vars
// TODO: Add other feature arrays
float32_t *data_freq;
float32_t *data_time;
float32_t *data_eng;

float32_t data_feature1[400] = {10.7174106735069,7.257917088218,10.3472336346979,9.57103746721614,7.79777153247961,10.6664272451793,11.9043630871608,13.3858508815419,12.6211088110972,7.79603594196122,9.68687474209005,12.8071529555944,16.911120191644,7.02727801636119,13.3092219003908,8.22320486877246,9.58872271572423,13.3055875697656,10.2012210679982,8.29607910739996,9.73049946412066,11.106773204202,7.56595027533773,15.4245014674882,9.86199551231365,9.80492656885067,14.002426688853,9.33984116872628,10.70574297189,9.69713746878784,9.444657501417,12.859859106359,15.956207334435,13.1303802692123,13.7091893276522,7.43042075792217,10.5393254004082,8.51612277845723,8.21894558159348,10.9726067493055,11.5425705692379,15.8634180461593,8.6549037183753,8.28431609818861,14.9467464735704,11.1679373190203,8.83632661844659,16.2622770429468,7.36522402540136,8.73680635348109,12.9130253453772,9.52074171580227,14.5402643001825,13.5134161199039,10.2365629629143,16.1800759639737,9.00227036434218,15.9042318707393,7.90684297246271,10.1167139013524,12.3920616293035,11.7062804662619,13.1369746838517,9.59522753715835,15.0708113328828,11.6050536260292,7.70691867984498,8.47446523983754,14.7295497952512,13.0509239837637,12.4057363240048,7.54364353275087,10.1604357371913,11.1785201655654,11.5348347951509,15.0999355537944,11.3988207812053,9.28792328309337,13.4296141239864,13.9994617979416,12.4630907234645,7.16748423251603,15.3706672141981,12.9078045384271,12.8755882648143,9.4809372854748,11.6245703606048,15.1341191509383,8.82131845255947,12.7043152919496,16.4557518038654,11.0188520647904,10.9682901157311,16.8340426191224,13.5651760588681,9.36349590435747,15.7964321225481,11.4368719208664,8.79470279003254,14.4869801305492,11.3215014353245,7.68929556885931,16.3479267634681,11.9756921423483,15.7832486608483,14.0078103301589,12.8287602023584,12.6773562282382,9.19263047170933,15.6499620041022,14.1822664061049,9.31955210994613,14.1603895631875,16.5492072709059,14.3824911396962,15.1320780406819,11.9563948987823,10.4838492098166,13.5276102730996,15.8432921221402,16.3132744629862,11.3274226244037,10.5441321138191,10.1069046378643,15.69764537492,10.2513063773934,14.6222633600727,13.5861248612321,16.3298655920813,11.3642801048801,10.9224893276411,10.8413487233372,13.0642207481847,14.4523959553907,3.23342025517241,5.48191383575239,2.60674672051701,2.03235888896827,3.79901470780573,6.44541362769056,6.78728301682949,6.82780072912963,2.74024411507289,4.15967686783509,6.16829768656028,2.37191253835728,4.15362462373002,6.63336695526443,2.43426488947851,5.97536777512964,5.01297761349924,6.59772407676405,4.33340703734519,4.04062623073247,4.41770946264555,4.37150107934015,4.11304501900258,4.2815820788221,4.30766675175692,5.53773085657556,6.13395475590292,6.15526053006865,4.67033268544158,6.13798754840685,2.42888510427676,2.70221763042253,4.6370460843849,3.76386203617185,4.25233301059512,3.51231059842934,6.42098943708954,5.74271864636576,4.47303381418389,3.28880935950216,6.77003785935584,3.63297540984759,6.99134778031479,5.18521056095374,4.20978721862284,3.81616673845824,3.590700633839,5.97303348953419,6.73384359743372,4.16405699694872,5.50748974310759,6.41487549614909,3.24415245137007,6.19005109948719,3.17925689058319,4.18677662188719,6.53216730210594,3.01006176465769,5.35172767105835,3.51502400545049,6.55869460732729,3.52757279250305,5.60083745684247,2.55487241306744,2.68223457977086,5.19127906698268,4.86144113218987,6.5770019283263,4.77342559625021,2.80977462704485,6.97781856812388,5.30966716954233,3.08695953930568,3.97036035154817,6.25178559209393,3.24896129501877,2.53794249456312,4.17656696537288,2.54547160584066,4.03647777957161,3.62942777669074,6.56103850196449,4.52553598861353,3.78970788955982,6.12216781471192,6.8085153104675,2.13267166198623,3.61240331335552,2.14710619474762,5.07843272062942,2.9616082888423,6.73253416621538,4.71160618416018,2.1999165889293,4.74526410405244,2.76617116557381,4.74361924124624,3.15644436070232,4.86620307486289,4.16846334611742,6.37823692574675,2.91175948360802,5.74520415213638,5.87266082522678,4.23468190170674,4.00693295386581,4.52915476746118,5.26569001860459,5.01785171751084,6.49318187762906,3.88614066851653,2.71247719543872,6.45505442068831,6.50049704738947,6.85286959509322,5.56566018237387,3.61750258052783,3.56733416642769,5.54731092282294,4.7878024845198,3.05365631052339,6.42486452923045,4.65731314845308,3.90116956021863,3.22763255515682,6.72268387479658,5.9024635481895,2.88706231178523,2.372441633023,6.27790963423221,3.94274575903261,4.05708811112918,6.26757352638407,1.64332360881347,0.0326272937601526,1.10004660927119,1.84436289192627,1.79725876887722,0.244297443567068,0.921171899438654,0.0359341996941696,1.84435660939589,0.0649294365511821,0.835517680999491,1.80345608864447,0.764387828372341,1.74973108216718,0.97138829349343,0.224727825996054,0.96953474616845,1.77891122347474,1.65353161063362,1.28360651714845,1.10097043075902,0.212904959339051,1.96527971414383,1.19873098901189,0.638870380907317,0.992493674980191,1.74533092639948,0.494247339768347,1.38982927862194,1.55705980741385,1.56449893944222,0.796114301381385,0.968850538528818,1.71475346246583,1.57442005753041,1.52872785146002,1.82418140135109,0.643933747506244,1.16965741593612,1.43600482579345,0.261011759119917,0.888532400287178,0.900076922701,1.94303117074337,0.266753312642171,0.867317042980627,0.809614946756002,0.0477190412698845,0.387983217862804,0.464514349153546,0.692347520029588,0.431825315700149,0.94109514661961,1.3344354717607,0.449890105659156,0.532213168228135,1.59539414615744,1.14251767811581,0.376027565750371,0.647842048931725,1.34998055837057,1.35683045078282,1.81881497314256,1.57909348982888,0.307737636278998,1.94186541597926,0.62310882998329,0.887874148378458,1.18346116985981,1.32885910994579,1.1234006289807,1.8713028691056,1.98864724376442,1.02159024987978,1.65203433115571,1.90237045094663,1.30473480833244,1.99397754305114,0.645696535643075,0.426328157427187,0.22328508664619,1.35860243073189,1.53221745334294,0.632274564083794,0.133433380511391,1.03221799377587,0.487335654059557,0.128682663123369,1.74847792104243,1.35721786406096,1.644603205492,1.88250424429941,1.87417520306242,1.06729288767056,1.86346721100501,0.00531867804977582,1.24390251188396,1.90658762583991,1.14391618149417,1.73190796606651,1.69129308425908,1.09488583926261,0.941322730112302,1.69096025356762,1.59004540535853,0.242275958590175,0.998656364744804,0.433128150697187,0.412625770693928,1.95307394946358,1.32939575543306,1.2899447458725,0.934390840419644,0.957158873715002,1.15013592711673,0.683482875377218,1.58114905033335,1.8193152204946,1.42446655044371,0.66939095902397,1.83148382876702,0.591408242449421,0.689800634150898,0.786627985412343,0.929843218969361,0.443425580414221,0.982577050670385,0.287968719497899,0.328322054042363,1.9989688127848,1.55790087339444,1.27622129147366,1.77392125333892};
float32_t data_feature2[400] = {10.2128370037025,14.4279660163418,12.0123864841677,13.5909171181913,15.6453749220415,16.4908843713467,16.0166698371314,13.7165268724505,16.7257917317331,11.7317606787106,14.5670507653087,10.5362035264908,9.82541145151898,13.9171764466085,13.4806238610079,9.70131788405685,9.53625242942504,16.2635446248011,12.7710708587014,13.6422281972022,7.77669499875081,8.95213810768607,8.40476209705262,14.665921822339,12.1492073183424,13.7082488161961,16.888233395495,8.61888131399165,12.3758053039692,12.6334932082344,7.47049501467343,12.0688732509092,16.2141340553416,9.934367093831,11.690334638398,11.6817959283373,8.75069162991803,14.0311479831254,13.7010613878889,15.3630412056521,9.41758167825564,13.5341030258593,7.14762218707639,16.715094571784,9.58644257699573,14.2953239350281,9.61727421159089,10.0274769103734,8.35592284641052,8.91929379735221,14.2572319770688,16.050821374135,9.90202734490764,13.5304182377823,13.8566795376406,10.4072022173568,10.0454909984888,15.1423313508536,8.74027937353294,15.4791297283922,13.5291877131333,9.113347316711,8.56963103656961,15.2006240525147,12.3829728887719,14.4437572663397,15.6845122157359,14.1310588913542,11.1960942065342,14.8567301193137,11.5968545516514,7.41171104211846,16.3740562396922,7.2970867830757,12.6881423440969,14.2670217529766,10.2502262162918,7.45755940135115,8.06403517039841,14.4652234831905,13.6921087507969,12.6831102529889,11.5435554917119,9.23002565304895,12.084630735973,13.4091952805285,15.634396276274,16.7240812828589,8.2734116148328,11.4531780925242,11.3424210820712,16.7352144789912,15.5751946921327,7.98275934810743,14.9203950683099,12.1638641892407,15.5399316287451,12.6857116498707,11.8907576528361,8.87864648207762,16.039187612472,11.2767165787326,7.78928749448877,12.8238702458499,9.97373131891405,10.8417585544635,16.8240575408281,8.45706898346151,10.3987039927766,13.8619770681935,9.77585169793599,16.887905481202,10.1921176890814,8.40725991965603,14.4852890774456,7.74412759782479,12.3804652406525,16.3015348224153,8.4630260230851,10.3414100030018,12.5549964400493,12.8529172307883,8.63371162705265,10.2255092431871,8.13363857873048,7.45332725171508,15.0129635552226,10.8024842728498,9.93984433497425,15.4865880031277,11.5552130270452,8.97910860535803,11.7850041162327,10.346698701546,6.98187678334969,6.19377977853045,4.10117387196208,3.04857318465161,3.8625816556272,4.69602783803511,3.59602422975218,4.15540527828272,3.07674380249503,6.64892250152435,2.18575741046546,2.64603065367406,2.13540284475386,5.67466192666688,5.17026440736436,2.28149045900371,6.61445257265792,6.66642726909223,5.69856321271834,6.19589763281246,5.48096191684957,3.48700920041415,2.48909142280348,2.02646442968342,6.28065613930757,4.18026888023111,4.32701499331895,4.99342268110259,3.13961149340815,4.98552342494042,4.41224396193394,2.56684062323582,4.74002386500591,6.47065308859709,6.85659380334333,4.25130022366827,5.76346844156428,2.35309033360063,5.60627008458402,4.72789505226985,4.36872035532323,4.71112401003812,6.27237772759853,4.53547725568795,2.60431743924579,6.35059817609955,5.01983454272135,4.67277684969269,3.66091487988803,5.28641061936207,5.03096223347551,4.11998277777021,6.3620935030694,3.50001225236767,6.81175862538369,5.28704617632156,6.77585595519276,3.59059294226113,2.7624755671624,5.01101535558628,3.32367618923297,6.813302211263,3.3642302143244,3.13088143499477,2.62667081485255,5.4863380760117,3.00334053923581,3.57621123356463,4.89349056330879,3.78036582402428,3.49698664541881,5.84444225899751,5.17485029862942,3.43588585502215,4.41066966708575,4.77404864309011,2.61682049153333,3.01171786349348,6.08421585975436,2.22439302518757,5.76808845423685,4.4668226224113,2.73174709341812,3.20160945921984,6.14560785770421,3.12630707243319,6.83235996826983,3.48356571620062,2.72327023526221,6.30787583112112,2.90718965121237,5.98913529627742,6.4695971457434,3.64010318934626,5.26761693673545,3.96287436065764,6.27461023181779,4.39962103796543,6.53569772165233,4.80630744937221,5.25268468659867,4.62287384089516,5.24214289435917,6.15626061777327,3.91007680220395,5.58089784450977,2.2466394823594,4.13965997897493,3.81959225519977,2.97494862564338,3.78805194188584,6.92740450996363,6.07879575222663,2.07871106180869,6.90442827622872,4.43789228528802,5.88752116184473,6.24089087421768,2.66103853610592,4.88409334869998,4.30632429451466,4.26233575980014,6.57805978248114,2.19401171895133,5.46582523165072,4.77757527425655,2.34502010124768,5.46995077445909,3.23967088121996,4.6221135650169,3.72541363970113,6.10981817817322,6.44895570398497,1.10570864441299,0.101918630733984,0.621415973741884,1.11711360783936,0.776709517992341,1.01980942417001,0.624246837812799,0.51489599755298,1.88180722894334,1.56780462974474,1.08732916579527,0.463138496903746,1.64165000208463,0.226959311190729,1.9925128554281,0.717000942832394,1.73700946302692,0.698811303465236,0.319250221931589,0.456960871437714,1.26511839783204,0.534027949557837,0.802448269325512,1.73617580354013,0.0295439289615165,1.88967323981237,1.54345304576573,1.31128198567701,1.21398356067411,1.71554830202579,1.41263359148805,0.336573647620891,1.52430672065295,0.00281496569817907,1.04496171750942,1.86641232049769,1.9271623025827,0.0747623463901799,1.40273329481172,0.165025827144708,1.54691531891233,0.679292494639849,0.613187399962683,1.33438251623574,1.40290336355485,0.124995739586126,0.613864903309896,0.42117613917742,1.8233998134119,1.31962538095555,1.02106981881924,0.787749250380373,1.55313602123232,1.57684294551707,1.32456890770264,1.64013767991162,0.58832089978537,0.252518911506566,1.468445798823,1.14560709421151,1.13375779590876,1.40676629815815,1.88720410793219,1.58604928332938,1.63062549419714,0.638402600807673,0.441829925197283,0.760119544007202,1.52710373560226,1.83007140363179,1.61013086848805,0.322928732922506,1.70269626596473,0.0536580307490404,0.699521985772451,0.297922966364036,1.20016936547283,1.59591083456439,0.664523182923164,0.360562010926035,0.617449299953154,1.89496788121923,1.91399657219736,0.638951919221335,1.13302497085953,1.80033255742111,1.45228697498365,1.84740758641834,0.416656588558231,1.1281055030934,0.987091168123273,0.869216368969926,0.030274275044015,1.6034487871095,1.94352378396998,0.269611541038559,0.155449156110238,0.324463607585787,1.94470702103703,0.538086338663502,1.12214834971582,1.52817169864063,1.5004077729837,1.55215687989111,1.46727763592759,1.47693916782758,1.10659632128138,0.800978371053878,0.213286128592487,1.74607248856975,1.35183414002399,1.79338403536245,0.212086192815471,0.237726150969048,1.66511784573794,0.576957524338569,1.20700613014651,1.96747984588066,1.71086450801685,1.56138737176766,0.480940706021686,0.932232488481759,1.71719881860328,0.463814194803015,1.60874181602342,0.750813837647549,0.673387187805462,0.77920678669542,1.23036047954473,0.523120777533206,0.46672884926568,0.307299667169707,0.657104535964497};
float32_t data_feature3[400] = {7.34446284048881,16.7712720580642,13.475087363505,12.4763987360415,11.4505209137035,7.46315256055496,10.7321146733925,16.1394005577214,10.5429144927109,11.7334077781738,10.6186856501267,15.3032317708569,10.7165710408053,10.9549911110644,10.9704469987806,14.2837047507697,14.1014999075147,11.1817659367547,16.4100221326393,13.8413620070387,12.5717660095501,9.816913930661,10.1051837327445,16.1291526533988,15.6351418910101,12.1382174884573,14.9387645527632,13.1396299573647,15.0374636964533,9.59469142488549,8.70340651904402,15.2748577565839,10.1812826134022,10.257186787964,10.3543859741396,12.1500634377392,9.78280568473752,7.5706915223788,14.782726493776,7.34823927640291,15.606863812404,10.2615561576458,15.0771240007271,7.36375433226993,11.3990873920604,14.88226289654,15.8593040153518,13.7186841614441,16.3205664647604,12.8494346351718,12.1986262163602,14.8345923772157,12.418844349592,7.41558144204562,12.1810400414286,8.21966985901264,13.2174884987915,12.0481082099828,10.4323258979022,15.2235333950165,8.96510957802612,9.40378114960562,10.9768531726666,9.65453996851776,16.9738495920834,13.4423368605721,13.43050507013,7.84161715379659,15.2197119540711,8.50265748542571,9.91012147128375,13.5625819623193,15.3730642277036,11.0250042738091,10.2367811712256,8.58539928035263,14.7584914339136,15.1658012594608,15.5665851654226,10.8174680506877,10.8944535594056,13.2590794030296,10.6135029551038,9.44974915516971,13.522248589517,9.43245976757222,12.5187528652921,9.35837981910179,10.4906927583915,16.9449077022051,8.50279518549646,13.8769420473823,8.48403300977693,10.6635306185679,9.3478753702542,16.1129967579085,11.6674785530299,9.08423049816348,10.5136248004419,14.4207509211535,14.8549465951769,9.49972849054794,11.3449447247631,12.4402497659418,9.93050373668688,13.022574485428,9.9428455849306,8.67451579805372,14.5933771884324,10.1353709906269,9.14339794880459,14.8045370890829,10.6509657826073,11.0751259724188,13.1959125776047,15.734106849941,16.6432116150554,10.3722575181265,9.72218902656055,15.4790885108339,11.5659477924412,16.8377527063646,7.02006150861909,7.66863411442725,7.34594672637351,15.9476322937684,15.4555811130463,11.1975632109706,13.8142992532486,11.7392311399286,9.61894195978255,8.15510971774208,16.156095586234,11.4478183226171,3.58264746481823,4.57850573252096,5.64185363008918,3.1720881057191,5.46732777860527,5.58240192598527,6.41031200823002,3.6697733043292,3.21309015865112,6.55918532916958,5.4320977384938,3.98327788216424,3.10946388050008,6.9706250754588,6.06798493688765,3.5047147015757,5.23184732255876,5.46906983231277,6.58758750827922,2.85572115534727,2.90832480525999,5.71147213284454,4.58022394971156,6.12907799892774,5.29160431065564,4.25372257229118,6.52250017375404,4.07989394718258,3.21633800060585,2.75192783949682,5.40499351873932,3.38909445663061,3.83189815145987,5.89817041750852,4.84167723039628,2.17027035387657,5.95206253648,4.07614726803143,2.02747595671591,5.74360377743644,4.19486822638246,6.11323495112481,4.41273191833132,3.64045707175506,2.9642207460703,2.30062991521251,4.04283929722362,5.93561485026038,3.22330424014891,2.14553736380403,3.61268770386644,2.39880750729614,2.01655347345142,4.35845812619867,4.37132244012782,6.46551662470477,6.55386480563969,3.23786594171699,4.57991637389369,5.06564586093376,6.65946506892308,4.58596315634026,6.05540403881386,3.13002002853641,3.59196881523355,3.32753955023868,4.50148678128383,3.39959433331179,3.8600155329316,6.52968464247921,3.34316471294867,6.73992908266329,4.74214724618177,2.65486532387477,2.70515406075806,6.71313950514427,3.07131457230347,2.63431215181248,5.01293677778345,4.35947445934622,5.56454079020802,4.81107812895233,2.78486138769848,2.60490584339958,6.05422884035332,4.15405266079488,3.99937676257477,4.28066993411492,6.89141485448101,6.8591920857089,2.99942878412692,6.32701146363071,2.32710633697025,5.55740805237042,4.6643157128499,3.89212688961693,2.45811363993575,3.09044912484261,6.68287278636808,6.3729342558823,6.89829369886796,3.26041147132945,4.6381230834022,6.43386585084532,2.5592601310031,2.37522274929231,6.79679568575651,4.99887480713979,6.20991487590429,4.99352111484268,4.72403200969189,5.50408776605427,4.88399085087117,5.40145753569273,2.61991470063961,5.65162556294938,4.12849693008865,5.39388746498069,5.59736059461225,5.23471660050357,6.57930459988332,3.83961405911413,3.7429150129744,6.73598204741059,5.95636392977962,3.43012310954171,2.72614213933476,6.31447378817927,3.23325239425312,4.27732011673373,4.918145413481,2.28832331576911,5.03861542049875,0.152140236352998,0.849070312392872,0.554097723352848,1.00471434811889,0.125065453663985,0.669407398038263,0.791280010064163,1.64550778774268,0.719707877218561,1.09670977860085,0.825553264858329,1.92108981559111,1.60355405356316,0.0478049018162456,0.900672805913234,0.479536672268043,1.19718189210189,0.487929570566415,0.440164427790116,1.04439719688941,1.53484047455411,1.0879304332606,0.215582624172105,0.682851859144245,1.43943434588362,1.10877721621951,0.788797393151721,0.103453738533871,1.97584169293125,0.345643512373947,1.43160027053849,0.165187132917505,1.76246952441238,1.96665155750436,1.5229301220772,1.05698015007204,0.766992931417841,1.52409358028806,0.620776323644419,0.761389028607695,0.726852813908758,1.73044997899316,0.143299015093444,1.48215459995123,0.239964341230045,1.0405928283311,0.570679130263543,1.41663599091577,1.8926450491063,0.995061911169945,1.73919466584797,1.09856604482043,0.287693476062342,1.03751940522377,0.229482121601317,0.343324681026932,1.35338938153228,0.040727503851292,1.18894557931504,0.360461757444653,1.15853761665614,0.484070904353246,0.114793868764225,1.53097328874639,0.0258358163433379,1.17204496207274,0.879786008952649,0.852630577124861,0.53529346220448,0.284191127805573,1.8989819804695,1.9004822224766,0.763144168446045,0.554938125928501,1.6793954745906,0.319397149119923,0.193085871810619,0.840870507649155,0.315808408038884,0.247998307907749,0.927212234541687,0.808048920367927,0.446309071859379,0.904766321753073,1.449388213929,0.254812923014328,1.65795701882951,1.67054415842618,1.78146261682342,0.668245499506391,1.85214391358055,1.33935076355976,0.631698264739323,1.83919980300861,1.43010521788235,1.78315003876957,1.0094199368271,0.289092448527456,1.65503067416037,1.46522801713154,1.77565558911566,0.201734414193015,0.747018462852334,1.08834832415143,1.08005953799931,0.159578223294021,0.715523235071161,1.85640793901149,1.89987480421641,0.572154710757578,1.39581544261345,0.93734133040757,1.39768805427348,0.107356232209332,1.22244458834837,1.31571177868987,1.3763496081846,1.23184797088113,0.920191354626346,0.54170609901087,0.39489866171308,0.100305782528509,1.4574928962687,1.28428680030876,0.982269138177204,1.06277309360782,1.46169808081204,0.000713113915469243,1.05223330103151,0.883009039037525,1.28457942375142,0.179222225990298,1.89266235536991,};

#define DMA_BUFF_ELE_SIZE 516
#define DATASET_SIZE 721
#define EMISSION_SIZE 128
float32_t emissions[DATASET_SIZE][EMISSION_SIZE] = {0};
float32_t single_emiss[EMISSION_SIZE] = {0};
// matrix init.			
short int neighIndices[dataSize];
short int seeds[dataSize];
short int orderedList[dataSize];
float32_t coreDistList[dataSize];
signed char procesList[dataSize];
float32_t reachDistList[dataSize];
float32_t orderedReachDistList[dataSize];

short int clusterIndices[dataSize];
short int prevVectorIndices[crosPointNumber];
short int currVectorIndices[crosPointNumber];
short int prevCluster[simMatrixSize];
short int currCluster[simMatrixSize];
short int newClustTest[simMatrixSize];
	
int setClustersStart[maxClust];
int setClustersEnd[maxClust];
	
float32_t timeMin[simMatrixSize];
float32_t timeMax[simMatrixSize];
float32_t yMinEnd[simMatrixSize];
float32_t yMaxEnd[simMatrixSize];
float32_t yMinStart[simMatrixSize];
float32_t yMaxStart[simMatrixSize];
float32_t prevyMaxEnd[simMatrixSize];
float32_t prevyMinEnd[simMatrixSize];
uint32_t peaks_per_clust[simMatrixSize] = {0};

// !OPTICS vars

/* Private function prototypes -----------------------------------------------*/
static void init(void);

//Task function prototypes
void write_SD(task_s *task);
void sync_SD(task_s *task);
void calc_FFT(task_s *task);
void write_buffs(task_s *task);
void find_peaks(task_s *task);
void read_ev(task_s *task);
void read_pk(task_s *task);
void calc_optics(task_s *task);
void write_sigfox(task_s *task);

#ifdef WINDOWS_TESTING
void read_data_from_file(void);
void write_idx_to_file(void); 
void write_reach_to_file(void);
void read_emissions_from_file(void);
#endif

#ifdef WINDOWS_TESTING
void HAL_Init(void){};
#endif
void SystemClock_Config(void);
void buff_reverse(uint32_t *in, uint32_t *out);



uint16_t event_dma_buffer[2][SD_BUF_SIZE] = {0};
uint8_t env_dma_buffer[6];

uint16_t env[2] = {0, 0};			//Temperature, Humidity
uint16_t env_cmd = ENV_START_MEAS; 

uint8_t sigfox_cmd[15] = "AT$SF=12345678\r";

uint16_t cal_factor_s;

//Task handle definitions
task_s write_env_task, write_meas_task, write_fft_task, write_peaks_task;
task_s write_cont_task, sync_task;
task_s write_buffs_task;
task_s fft_task, find_peaks_task;
task_s read_ev_task;
task_s optics_task;
task_s write_clust_task;
task_s write_sigfox_task;



uint32_t cnt = 0, block_cnt = 0;//TEST
uint8_t sleeping = 0;

FIL env_file, meas_file, fft_file, peak_file, ev_file, clust_file;
uint32_t env_fp , meas_fp;
FATFS fs;
FRESULT fres;

uint32_t sd_wr_bytes;
volatile uint32_t sd_write_flag = SD_DMA_FLAG | SD_DONE_FLAG;
volatile uint32_t sigfox_write_flag = SIGFOX_RDY_FLAG;
#ifdef WINDOWS_TESTING
volatile uint32_t zero_flag = 0;
#endif

buffer_s dma_ev_buffer;
buffer_s event_buffer;
buffer_s env_buffer;
buffer_s fft_ev_buffer;
buffer_s fft_wr_buffer;
buffer_s fft_pk_buffer;
// TODO: Add other feature buffers
buffer_s peak_buffer;
buffer_s pk_freq_buffer, pk_time_buffer, pk_eng_buffer;
buffer_s clust_buffer;
buffer_s sigfox_msg_buffer;
buffer_s sigfox_env_buffer;

uint8_t *sigfox_msg_ptr;

struct SD_write_arg_s{
	FIL *fp;
	buffer_s *buff;
} env_args, event_args, fft_args, peak_args, clust_args;

struct FFT_arg_s{
	buffer_s *in_buff;
	buffer_s *out_buff;
}fft_calc_args;

arm_rfft_fast_instance_f32 fft_inst;
int16_t ev;

float32_t fft_freqs[128];
int main(void)

//I2C level shifter - U cemu je bio problem?


{
	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* Configure the system clock */
  SystemClock_Config();

	//Initialize the FFT instance
	arm_rfft_fast_init_f32(&fft_inst, 256);
	
	//Initialize the structures used for task arguments
	env_args = (struct SD_write_arg_s){.fp = &env_file,
							.buff = &env_buffer
	};
	event_args = (struct SD_write_arg_s){.fp = &meas_file,
							.buff = &event_buffer
	};	
	fft_args = (struct SD_write_arg_s){.fp = &fft_file,
							.buff = &fft_wr_buffer
	};
	// TODO: Should calculate 2 more features
	fft_calc_args = (struct FFT_arg_s){.in_buff = &fft_ev_buffer,
							.out_buff = &fft_pk_buffer
	};
	// TODO: Add SD_write_arg for 2 more features
	peak_args = (struct SD_write_arg_s){.fp = &peak_file,
							.buff = &peak_buffer
	};
	clust_args = (struct SD_write_arg_s){.fp = &clust_file,
							.buff = &clust_buffer
	};

	//Initialize all the tasks
	write_env_task = (task_s){.function = &write_SD, 
											.args = (void *)&env_args,
											.next = NULL,
											.flag = &sd_write_flag,
											.mask = SD_DONE_FLAG | SD_DMA_FLAG,
											.priority = 1
	};
	write_meas_task = (task_s){.function = &write_SD, 
											.args = (void *)&event_args,
											.next = NULL,
											.flag = &sd_write_flag,
											.mask = SD_DONE_FLAG | SD_DMA_FLAG,
											.priority = 2
	};
	write_cont_task = (task_s){.function = &write_SD,
											.args = (void *)&event_args,
											.next = NULL,
											.flag = &sd_write_flag,
											.mask = SD_DMA_FLAG,
											.priority = 4
	};
	sync_task = (task_s){.function = &sync_SD,
											.args = NULL,
											.next = NULL,
											.flag = &sd_write_flag,
											.mask = 0,
											.priority = 0
	};
	fft_task = (task_s){.function = &calc_FFT,
											.args = (void *)&fft_calc_args,
											.next = NULL,
											.flag = NULL,
											.mask = 0,
											.priority = 3
	};
	write_fft_task = (task_s){.function = &write_SD, 
											.args = (void *)&fft_args,
											.next = NULL,
											.flag = &sd_write_flag,
											.mask = SD_DONE_FLAG | SD_DMA_FLAG,
											.priority = 2
	};
	// TODO: Should write for 2 more features
	write_peaks_task = (task_s){.function = &write_SD,
											.args = (void *)&peak_args,
											.next = NULL,
											.flag = &sd_write_flag,
											.mask = SD_DONE_FLAG | SD_DMA_FLAG,
											.priority = 2
	};
	write_clust_task = (task_s){.function = &write_SD,
											.args = (void *)&clust_args,
											.next = NULL,
											.flag = &sd_write_flag,
											.mask = SD_DONE_FLAG | SD_DMA_FLAG,
											.priority = 2
	};
	// TODO: Should create calculation task for 2 more features
	find_peaks_task = (task_s){.function = &find_peaks,
											.args = (void *)&fft_pk_buffer,
											.next = NULL,
											.flag = NULL,
											.mask = 0,
											.priority = 3
	};
	write_buffs_task = (task_s){.function = &write_buffs,	//Problem ako se obavlja task koji dugo traje, a dolaze eventi
											.args = (void *)&dma_ev_buffer,
											.next = NULL,
											.flag = NULL,
											.mask = 0,
											.priority = 6
	};
	read_ev_task = (task_s){.function = &read_ev,		//Reading from SD for testing
											.args = NULL,
											.next = NULL,
											.flag = &sd_write_flag,
											.mask = SD_DONE_FLAG,
											.priority = 1
	};
	optics_task = (task_s){.function = &calc_optics,
											.args = NULL,
											.next = NULL,
#ifdef WINDOWS_TESTING
											.flag = &zero_flag,
#else
											.flag = NULL,
#endif
											.mask = 0,
											.priority = 5
	};
	write_sigfox_task = (task_s){.function = &write_sigfox,
											.args = NULL,
											.next = NULL,
											.flag = &sigfox_write_flag,
											.mask = SIGFOX_RDY_FLAG,
											.priority = 2
	};
	
	
	//Add all the sync tasks to the queue
	//They have the lowest priority and automatically re-add themselves to the queue on completion
	sync_task.args = &meas_file;
	sync_task.mask = SD_SYNC_MEAS_FLAG | SD_DONE_FLAG | SD_DMA_FLAG;
	queue_task(sync_task);
	
	sync_task.args = &env_file;
	sync_task.mask = SD_SYNC_ENV_FLAG | SD_DONE_FLAG | SD_DMA_FLAG;
	queue_task(sync_task);
	
	
	sync_task.args = &fft_file;
	sync_task.mask = SD_SYNC_FFT_FLAG | SD_DONE_FLAG | SD_DMA_FLAG;
	queue_task(sync_task);
	
	// TODO: Should have sync and file for 2 more features
	sync_task.args = &peak_file;
	sync_task.mask = SD_SYNC_PEAK_FLAG | SD_DONE_FLAG | SD_DMA_FLAG;
	queue_task(sync_task);
												
	sync_task.args = &clust_file;
	sync_task.mask = SD_SYNC_CLUST_FLAG | SD_DONE_FLAG | SD_DMA_FLAG;
	queue_task(sync_task);
															
															
	//Initialize all the buffers
	#ifndef WINDOWS_TESTING
	init_buffer(&dma_ev_buffer, 12, 516, &write_buffs_task, COND_ALWAYS);
	#else
	init_buffer(&dma_ev_buffer, 12, EMISSION_SIZE, &write_buffs_task, COND_ALWAYS);
	#endif
	init_buffer(&event_buffer, 12, 516, &write_meas_task, COND_HALF_FULL);
	init_buffer(&fft_ev_buffer, 12, 1028, &fft_task, COND_ALWAYS); //float32
	// TODO: Init other feature calculation buffers
	init_buffer(&fft_pk_buffer, 12, 516, &find_peaks_task, COND_ALWAYS);
	init_buffer(&fft_wr_buffer, 12, 516, &write_fft_task, COND_HALF_FULL);
	// TODO: Init other feature buffers
	init_buffer(&peak_buffer, 4, (2*4 + 2)*OPTICS_FRAMESIZE, &write_peaks_task, COND_HALF_FULL);
	//init_buffer(&peak_buffer, 32, 9, &write_peaks_task, COND_HALF_FULL);
	init_buffer(&env_buffer, 2, 10, &write_env_task, COND_ALWAYS);
	// TODO: Init other feature buffers
	init_buffer(&pk_freq_buffer, 2*OPTICS_FRAMESIZE-OPTICS_OVERLAP, 4, NULL, COND_NEVER);
	init_buffer(&pk_eng_buffer, 2*OPTICS_FRAMESIZE-OPTICS_OVERLAP, 4, NULL , COND_NEVER);
	init_buffer(&pk_time_buffer, 2*OPTICS_FRAMESIZE-OPTICS_OVERLAP, 4, &optics_task , COND_NUMBER|OPTICS_FRAMESIZE);
	init_buffer(&clust_buffer, 36, 32, &write_clust_task, COND_HALF_FULL);	//32-> floats : lmin, lmax, rmin, rmax, lx, rx 
																																					//  -> uint32 : clustNum, peaks_per_clust
	init_buffer(&sigfox_msg_buffer, 64, 13, &write_sigfox_task, COND_ALWAYS);	//Prebacivanje u HEX tek u write_sigfox tasku!
	
	
	//The peak arrays have memory allocated for an additional OPTICS_OVERLAP elements,
	//	which are copied to the end of the arrays so that they are always contiguous
	// TODO: Do for 2 other features
	pk_freq_buffer.n_elem = 2*(OPTICS_FRAMESIZE-OPTICS_OVERLAP);
	pk_eng_buffer.n_elem = 2*(OPTICS_FRAMESIZE-OPTICS_OVERLAP);
	pk_time_buffer.n_elem = 2*(OPTICS_FRAMESIZE-OPTICS_OVERLAP);

	
	uint32_t i = 0;
	
	//Generate window function
/*
	for (i = 0; i<256; i++)
		hann[i] = powf(sinf((float32_t)PI*(i/255.0)), 2);
*/	
	
	//Array of FFT frequencies needed for the OPTICS algo
	for (i = 0; i < 128; i++){
		fft_freqs[i] =FFT_RES * i;
	}
	
	init();
	//Write sigfox byte TEST
//	DMA2_Channel3->CMAR = (uint32_t)sigfox_cmd;
//	LPUART1->ICR |= (1<<6);
//	DMA2_Channel3->CCR |= 0x01;
//	LPUART1->CR3 |= (1<<7);
		
	//LPUART1->CR1 |= (1<<3);						//TX Enable
//	LPUART1->CR1 |= (1<<3)|(1<<2);						//RX & TX Enable
	
	//TXFNF - fifo not full
/*
	uint8_t id[9] = "AT$I=10\r\n";
	uint8_t pac[9] = "AT$I=11\r\n";
	uint8_t *msg_ptr = sigfox_cmd; 
	uint8_t msg_ctr = 0;
	uint8_t emu[10] = "ATS410=0\r\n";
	uint8_t rd_pwr[9] = "ATS302?\r\n";
	uint8_t oob[7] = "AT$SO\r\n";
	while(msg_ptr != NULL){
		LPUART1->TDR = *msg_ptr;
		if (*msg_ptr++ == '\r'){
			if (msg_ctr == 0) msg_ptr = NULL;
			else if (msg_ctr == 1) msg_ptr = emu;
			else if (msg_ctr == 2) msg_ptr = rd_pwr;
			else if (msg_ctr == 3) msg_ptr = sigfox_cmd;
			else msg_ptr = NULL;
			msg_ctr++;
		}
		while(!(LPUART1->ISR & (1<<7)));	//TXFNF
	}
*/
	//End test

#ifdef WINDOWS_TESTING
	read_emissions_from_file();

	// memcpy(single_emiss, emissions[0], sizeof(single_emiss));

	// Write to DMA buffer until whole emission is written
	// Not enough space beacause buffer is 516 * 12 < 6000 * 4 
	// for (int block_ind = 0; block_ind < EMISSION_SIZE; block_ind+=DMA_BUFF_ELE_SIZE)
	// {
	// 	float32_t single_emiss[DMA_BUFF_ELE_SIZE/sizeof(float32_t)] = {0};
	// 	// Copy from emission array but don't fill last element which is timestamp
	// 	uint32_t block_size = DMA_BUFF_ELE_SIZE/sizeof(float32_t);
	// 	for (int data_ind = 0; data_ind < block_size-1; data_ind++)
	// 	{
	// 		single_emiss[data_ind] = emissions[0][data_ind + (block_size*block_ind)];
	// 	}
	// 	// Set last element as timestamp
	// 	single_emiss[block_size - 1] = block_ind; // Fake Hardcoded timestamp
	// 	write_to_buffer(&dma_ev_buffer, (float32_t *)&single_emiss[0], 0);
	// }
	for (int data_ind = 0; data_ind < EMISSION_SIZE; data_ind++)
	{
		single_emiss[data_ind] = emissions[0][data_ind];
	}
	write_to_buffer(&dma_ev_buffer, (float32_t *)&single_emiss[0], 0);

	read_data_from_file();
	// for (i = 0; i < OPTICS_FRAMESIZE; i++)
	// {
	// 	write_to_buffer(&pk_time_buffer,&data_feature1[i],0);
	// 	write_to_buffer(&pk_freq_buffer,&data_feature2[i],0);
	// 	write_to_buffer(&pk_eng_buffer,&data_feature3[i],0);
	// }
#endif

	run_scheduler();

}


//This function writes messages from a buffer to sigfox via UART
uint8_t msg_out[41] = "AT$SF=";


#ifdef WINDOWS_TESTING
void write_sigfox(task_s *task){};
#else
void write_sigfox(task_s *task){
	uint8_t *wr_msg_ptr = &msg_out[6];
	uint8_t *rd_msg_ptr;
	static uint8_t hex_lookup[16] = "0123456789ABCDEF";
	uint8_t i = 0;
	uint8_t n_bytes = 0;
	
	sigfox_write_flag &= ~SIGFOX_UART_DONE_FLAG;
	read_from_buffer(&sigfox_msg_buffer, &rd_msg_ptr, 1);
	n_bytes = *rd_msg_ptr++;
	for (i=0; i<n_bytes; i++){
		*wr_msg_ptr++ = hex_lookup[(*rd_msg_ptr&0xf0)>>4];
		*wr_msg_ptr++ = hex_lookup[*rd_msg_ptr++&0x0f];
	}
	
	*wr_msg_ptr++ = '\r';
	*wr_msg_ptr++ = '\n';
	*wr_msg_ptr = '\0';
	
	
	sigfox_msg_ptr =msg_out;
	while(*sigfox_msg_ptr != NULL && (LPUART1->ISR & (1<<7))){
		LPUART1->TDR = *sigfox_msg_ptr;
		sigfox_msg_ptr = *sigfox_msg_ptr == '\n'?NULL:sigfox_msg_ptr+1;
	}
	LPUART1->CR3 |= (1<<23);
}
#endif



#define wi 0.5
#ifndef WINDOWS_TESTING
#define eps 10
#define Nmin 25
#else
volatile float32_t eps = 10;
volatile float32_t Nmin = 25;
#endif
#define largeClustPerc 0.8
#define mergePerc 0.8
#define t 160
#define minMax 2

int clustNum, newClustIndex = 0, iter = 0;
float32_t timeStampStart, timeStampEnd;


//This function finds clusters in one window of size OPTICS_FRAMESIZE
void calc_optics(task_s *task){
	int i;
	
	static float32_t out_param[8];
	float32_t clust_float;
	for(i=0;i<dataSize;i++){
		coreDistList[i]=-1;
		reachDistList[i]=-1;	
		neighIndices[i]=0;
		seeds[i]=0;
		clusterIndices[i]=0;
		procesList[i]=0;
		orderedList[i]=0;
	}	
	
	for(i=0;i<maxClust;i++){
		setClustersStart[i]=0;
		setClustersEnd[i]=0;
	}
	for(i=0;i<simMatrixSize;i++){
		newClustTest[i]=0;
		currCluster[i]=0;
		peaks_per_clust[i] = 0;
		timeMin[i]=0;
		timeMax[i]=0;
		yMinEnd[i]=0;
		yMaxEnd[i]=0;
		yMinStart[i]=0;
		yMaxStart[i]=0;
	}

	// TODO: Add reading from buffer for other features
	read_from_buffer(&pk_freq_buffer, &data_freq, OPTICS_FRAMESIZE-OPTICS_OVERLAP);
	if (pk_freq_buffer.rd_ptr == pk_freq_buffer.buff)
		memcpy(&data_freq[OPTICS_FRAMESIZE-OPTICS_OVERLAP], pk_freq_buffer.buff, 4*OPTICS_OVERLAP);
	
	read_from_buffer(&pk_time_buffer, &data_time, OPTICS_FRAMESIZE-OPTICS_OVERLAP);
	if (pk_time_buffer.rd_ptr == pk_time_buffer.buff)
		memcpy(&data_time[OPTICS_FRAMESIZE-OPTICS_OVERLAP], pk_time_buffer.buff, 4*OPTICS_OVERLAP);
		
	read_from_buffer(&pk_eng_buffer, &data_eng, OPTICS_FRAMESIZE-OPTICS_OVERLAP);
	if (pk_eng_buffer.rd_ptr == pk_eng_buffer.buff)
		memcpy(&data_eng[OPTICS_FRAMESIZE-OPTICS_OVERLAP], pk_eng_buffer.buff, 4*OPTICS_OVERLAP);
	
	optics (eps, Nmin);
	
	for (i = 0; i < dataSize; i++){
		orderedReachDistList[i] = reachDistList[orderedList[i]];
		if (orderedReachDistList[i] == -1)
			orderedReachDistList[i] = maxdist;
	}
#ifdef WINDOWS_TESTING
	write_reach_to_file();
#endif
	clustNum = gradientClustering( Nmin, t, wi, largeClustPerc, mergePerc, minMax);
	getClusterIndices(clustNum);

#ifdef WINDOWS_TESTING
	write_idx_to_file();
#endif
	
	newClustIndex = opticsMerging(clustNum, iter, newClustIndex);
	timeStampEnd = data_time[dataSize - 1];
	
	// TODO: Refactor below for other feature
	featureExtraction(clustNum, timeStampEnd, timeStampStart, Nmin);
	iter = 1;
	timeStampStart = timeStampEnd;
	
	for(i = 0; i<simMatrixSize; i++){
		prevCluster[i] = currCluster[i];
		prevyMaxEnd[i] = yMaxEnd[i];
		prevyMinEnd[i] = yMinEnd[i];
	}
	for(i = 0; i < crosPointNumber; i++){
		prevVectorIndices[i] = clusterIndices[dataSize-crosPointNumber+i];
	}

	uint8_t sigfox_msg[13] = {0};
	uint32_t t_start;
	uint32_t t_diff;
	uint8_t f_st_min, f_st_max, f_end_min, f_end_max;
	uint8_t pk_per_clust;
	for (i = 1; i <= clustNum; i++){
		clust_float = (float32_t)currCluster[i-1];
		out_param[0] = clust_float;
		out_param[1] = timeMin[i];
		out_param[2] = yMinStart[i];
		out_param[3] = yMaxStart[i];
		out_param[4] = timeMax[i];
		out_param[5] = yMinEnd[i];
		out_param[6] = yMaxEnd[i];
		out_param[7] = peaks_per_clust[i];
		write_to_buffer(&clust_buffer, &out_param[0], 0);
		
		t_start = (uint32_t)(timeMin[i]*3600); //U sekunde
		t_diff = (uint32_t)((timeMax[i]-timeMin[i])*3600); //U sekunde
		f_st_min = (uint8_t)(yMinStart[i]/FFT_RES);
		f_st_max = (uint8_t)(yMaxStart[i]/FFT_RES);
		f_end_min = (uint8_t)(yMinEnd[i]/FFT_RES);
		f_end_max = (uint8_t)(yMaxEnd[i]/FFT_RES);
		pk_per_clust = peaks_per_clust[i]>255?255:peaks_per_clust[i];
		
		sigfox_msg[0] = 12; //12 bytes in message
		sigfox_msg[1] = f_st_min;
		sigfox_msg[2] = f_st_max;
		sigfox_msg[3] = f_end_min;
		sigfox_msg[4] = f_end_max;
		sigfox_msg[5] = pk_per_clust;
		sigfox_msg[6] = currCluster[i-1];
		sigfox_msg[7] = (t_start&0x0ff00000)>>20;
		sigfox_msg[8] = (t_start&0x000ff000)>>12;
		sigfox_msg[9] = (t_start&0x00000ff0)>>4;
		sigfox_msg[10] = ((t_start&0x0000000f)<<4)|((t_diff&0x000f0000)>>16);
		sigfox_msg[11] = (t_diff&0x0000ff00)>>8;
		sigfox_msg[12] = t_diff&0x000000ff;

		write_to_buffer(&sigfox_msg_buffer, sigfox_msg, 0);
	}
	memcpy(peak_buffer.wr_ptr, data_freq, OPTICS_FRAMESIZE*4);
	memcpy(&peak_buffer.wr_ptr[OPTICS_FRAMESIZE*4], data_time, OPTICS_FRAMESIZE*4);
	memcpy(&peak_buffer.wr_ptr[OPTICS_FRAMESIZE*8], clusterIndices, OPTICS_FRAMESIZE*2);
	write_to_buffer(&peak_buffer, NULL, 0);
	//write_to_buffer(&peak_buffer, (uint8_t *)clusterIndices, 0);
	//Temp, voltage, humidity -> Cuvati zadnji
	//Probaj procitati iz sigfox_env_buffer, ako ima zamijeni ako ne nista
	//sigfox_env_buffer ima samo 1 mjesto, overwrite-a se
	//Serijaliziraj u kolko vec treba bita
	//Prvi bit-> broj bitova u poruci
	
	
	
}

#ifdef WINDOWS_TESTING
void read_ev(task_s *task){};
#else
//This function reads the events from SD card, only used for testing
uint16_t read_ev_buff[1026];
void read_ev(task_s *task){
	static uint32_t done_cntr = 0;
	uint32_t read_bytes = 0;
	f_read(&ev_file, (uint8_t *)read_ev_buff, 2052, &read_bytes);
	if (read_bytes != 2052){
		if(done_cntr == 0){
			queue_task(write_meas_task);
			queue_task(write_env_task);
			// TODO: enqueue task for writting other features
			queue_task(write_peaks_task);
			queue_task(write_clust_task);
			queue_task(write_fft_task);
		}
		done_cntr += 1;
	}
	if (done_cntr > 5)
		Error_Handler();
	*(uint32_t *)&read_ev_buff[258] = *(uint32_t *)&read_ev_buff[0];
	write_to_buffer(&dma_ev_buffer, &read_ev_buff[2], 0);
//	write_buffs_task.args = (void *)&read_ev_buff[2];
//	queue_task(write_buffs_task);
}
#endif

#ifdef WINDOWS_TESTING
void read_pk(task_s *task){};
#else
float32_t read_pk_buff[64];
void read_pk(task_s *task){
	static uint32_t done_cntr = 0;
	uint32_t read_bytes = 0;
	uint8_t i = 0;
	f_read(&ev_file, (uint8_t *)read_pk_buff, 256, &read_bytes);
	if (read_bytes != 256){
		if(done_cntr == 0){
			queue_task(write_peaks_task);
			queue_task(write_clust_task);
		}
		done_cntr += 1;
	}
	if (done_cntr > 5)
		Error_Handler();
	for (i = 0; i < read_bytes/4; i+= 2){
		write_to_buffer(&pk_freq_buffer, &read_pk_buff[i], 0);
		write_to_buffer(&pk_time_buffer, &read_pk_buff[i+1], 0);
		// write_to_buffer(&pk_eng_buffer, &read_pk_buff[i+1], 0);
	}
}
#endif

//This function writes the data captured by ADC to two buffers
//The event_buffer has int16_t data written to it for writing to the SD card
//The fft_ev_buffer has float32_t data written to it for calculating the FFT
void write_buffs(task_s *task){
	int i = 0;
	int16_t *data_ptr;
	read_from_buffer((buffer_s *)task->args, &data_ptr, 1);
	float32_t float_meas = 0;
	uint32_t tstamp = *(uint32_t *)&data_ptr[EMISSION_SIZE];
	
	for(i = 0; i < EMISSION_SIZE; i++){
		float_meas = (float32_t)__REVSH(data_ptr[i]);
		//float_meas = (float32_t)data_ptr[i];
		*(float32_t *)&fft_ev_buffer.wr_ptr[4*i] = float_meas;	//*hann[i];
		*(int16_t *)&event_buffer.wr_ptr[2*i] = data_ptr[i];
	}
	*(uint32_t *)&event_buffer.wr_ptr[512] = tstamp;
	*(float32_t *)&fft_ev_buffer.wr_ptr[1024] = (float32_t)tstamp;
	write_to_buffer(&event_buffer, NULL, 0);	//Not very good (writing the same thing to 2 buffers)
	write_to_buffer(&fft_ev_buffer, NULL, 0);
}


//This function calculates the magnitude of the FFT and writes it to fft_wr_buffer for peak extraction
float32_t fft_out_buff[256];
// TODO: Change to your impulse response values
float32_t freq_corr_coeff[128] = {0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
																	0.000000, 33.411149, 31.815871, 29.778722, 28.564342, 27.563829, 26.473560, 25.554871, 25.752341, 25.118447, 
																	23.954304, 21.345067, 19.526610, 17.968908, 15.410955, 11.279486, 12.570676, 11.680531, 12.064913, 15.393897, 
																	15.827324, 11.079429, 8.239959, 6.610569, 5.838361, 5.712504, 5.853093, 5.677902, 5.278572, 5.390433, 
																	6.805924, 4.076498, 3.423678, 3.205529, 3.023403, 2.755062, 2.808081, 2.572367, 2.348886, 2.125532, 
																	1.958052, 1.831452, 1.717388, 1.667712, 1.487046, 1.216917, 1.251416, 1.753888, 2.035280, 2.098273, 
																	1.713967, 1.714329, 1.680745, 1.901089, 1.553013, 1.185858, 1.043954, 1.020481, 1.181269, 1.356855, 
																	1.370399, 1.835487, 2.372067, 2.650552, 2.455239, 2.403643, 2.691563, 3.455798, 3.856046, 4.225251, 
																	4.923597, 6.170836, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
																	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
																	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
																	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 
																	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000};
void calc_FFT(task_s *task){	//Windowing -> Treba dodati direktno pisanje u buffere
	float32_t *in_buff;
	int i;
	float32_t max = 0;
	
	struct FFT_arg_s *args = (struct FFT_arg_s *)task->args;
	
	read_from_buffer(args->in_buff, &in_buff, 1);
	arm_rfft_fast_f32(&fft_inst, in_buff, fft_out_buff, 0);
	arm_cmplx_mag_f32(fft_out_buff, (float32_t *)args->out_buff->wr_ptr,128);
	*(float32_t *)&args->out_buff->wr_ptr[512] = *(float32_t *)&in_buff[256];
	write_to_buffer(&fft_wr_buffer, args->out_buff->wr_ptr, 0);
	
	// TODO: Change equalization after FFT -> to convolution: arm_conv_f32
	arm_mult_f32((float32_t *)args->out_buff->wr_ptr, freq_corr_coeff, (float32_t *)args->out_buff->wr_ptr,128);
	for (i = 10; i < 128; i++){
		if(((float32_t *)args->out_buff->wr_ptr)[i] > max)
			max =((float32_t *)args->out_buff->wr_ptr)[i];
	}
	arm_scale_f32((float32_t *)args->out_buff->wr_ptr, 1.0f/max, (float32_t *)args->out_buff->wr_ptr, 128);
	write_to_buffer(&fft_wr_buffer, args->out_buff->wr_ptr, 0);
//	*(float32_t *)&args->out_buff->wr_ptr[512] = *(float32_t *)&in_buff[256];
	write_to_buffer(args->out_buff, NULL, 0);
}


#ifdef WINDOWS_TESTING
void write_SD(task_s *task){};
#else
//This function writes data to the SD
void write_SD(task_s *task){
	static uint32_t cont_args[3] = {0};
	struct SD_write_arg_s *args;
	volatile uint32_t *flag = task->flag;
	uint8_t *buff = NULL;
	uint32_t elem_to_write, bytes_to_write;
	FIL *file;

	if (cont_args[0] != 0){ //Continuation, nothing to do with the queue
		bytes_to_write = cont_args[0];
		buff = (uint8_t *)cont_args[1];
		file = (FIL *)cont_args[2];
		cont_args[0] = 0;
	}
	else {
		args	= (struct SD_write_arg_s *)task->args;
		
		elem_to_write = read_from_buffer(args->buff, &buff, 0);	//TODO : Novi read_from_buffer, ne treba loop(vjerojatno)
		if (elem_to_write == 0)
			return;
		bytes_to_write = elem_to_write*args->buff->size_elem;
		
		file = args->fp;
	}
	
	fres = f_write_DMA(file, buff, bytes_to_write, &sd_wr_bytes, flag);
	if (sd_wr_bytes < bytes_to_write){
		*flag &= ~SD_DONE_FLAG;
		cont_args[0] = bytes_to_write - sd_wr_bytes;
		cont_args[1] = (uint32_t)&buff[sd_wr_bytes];
		cont_args[2] = (uint32_t)file;
		queue_task(write_cont_task);
	}
	else{
		*flag |= SD_DONE_FLAG;
		if (file == &meas_file)
			*flag |= SD_SYNC_MEAS_FLAG;
		else if (file == &env_file)
			*flag |= SD_SYNC_ENV_FLAG;
		else if (file == &fft_file)
			*flag |= SD_SYNC_FFT_FLAG;
		// TODO: Add support for other feature files
		else if (file == &peak_file)
			*flag |= SD_SYNC_PEAK_FLAG;
		else if (file == &clust_file)
			*flag |= SD_SYNC_CLUST_FLAG;	
	}
}
#endif

//This function finds the peaks in the magnitude FFT of the events
#define MIN_PROM 0.3f
#define MIN_WIDTH 2
#define WIDTH_MUL 0.5f

void find_peaks(task_s *task){
	float32_t *x;
	uint32_t	n_data, i, j, pts_left = 0;
	//uint8_t n_peaks = 0;
	float32_t pts_leftover = 0;
	float32_t time_h;
	float32_t min_amp;
	
	uint32_t max_idx = 0;
	float32_t max_amp;
	
	uint8_t cand_flag = 0x00;
	
//	uint32_t peak_idx[16];
//	float32_t peak_amp[16];
	
	//static uint8_t wr_buff[9] = {0};
	
	read_from_buffer((buffer_s *)task->args, &x, 1);
	time_h = x[128]/(100*60*60);
	min_amp = x[10];
	max_amp = 0;
	
	n_data = ((buffer_s *)task->args)->size_elem/4 - 1;
	
	for (i = 10; i < n_data; i++){
		if (x[i] - x[i-1] > 0 && x[i] - x[i+1] > 0) {	//local maximum
			if (x[i] - MIN_PROM > min_amp){							//satisfies left prominence
				max_idx = i;
				max_amp = x[i];
				cand_flag &= 0x00;
				min_amp = x[i] - MIN_PROM;
			}
		}
		if (x[i] - x[i-1] < 0 && x[i] - x[i+1] < 0) {	//local minimum
			if (x[i] < min_amp) {
				min_amp = x[i];
				if (max_amp - MIN_PROM > min_amp)	{				//satisfies right prominence
					if (cand_flag & 2) {										//passed width check already
						//wr_buff[0] = n_peaks++;
						//*(uint32_t *)&wr_buff[1] = max_idx;
						//max_as_int = *(uint32_t *)&max_amp;
						//*(uint32_t *)&wr_buff[5] = *(uint32_t *)&max_as_int;
						//write_to_buffer(&peak_buffer, wr_buff, 0);
						write_to_buffer(&pk_freq_buffer, &fft_freqs[max_idx], 0);
						write_to_buffer(&pk_time_buffer, &time_h, 0);
						cand_flag &= 0x00;
						max_idx = 0;
						max_amp = 0;
					}
					else
						cand_flag |= 1;
				}
			}
		}
		
		if (max_idx != 0 && (x[i] - max_amp*WIDTH_MUL < 1.0f/10000 || i - max_idx == MIN_WIDTH + 1)) {	//got to width or
			pts_leftover = 0;																																						// amp below threshold
			if (i - max_idx < MIN_WIDTH + 1) {
				pts_left = MIN_WIDTH - i + max_idx + 1;
				pts_leftover = (max_amp*WIDTH_MUL - x[i-1])/(x[i] - x[i-1]);
			}

			for (j = 1; j <= pts_left; j++) {
				if (x[max_idx - j] <= max_amp * WIDTH_MUL || x[max_idx - j] >= max_amp) {
					pts_leftover += (max_amp * WIDTH_MUL - x[max_idx - j + 1])/(x[max_idx - j] - x[max_idx - j + 1]);
					break;
				}
				pts_left -= 1;
			}
			if (pts_left - pts_leftover <= 0) {
				if (cand_flag & 0x01) {
					//wr_buff[0] = n_peaks++;
					//*(uint32_t *)&wr_buff[1] = max_idx;
					//max_as_int = *(uint32_t *)&max_amp;
					//*(uint32_t *)&wr_buff[5] = *(uint32_t *)&max_as_int;
					//write_to_buffer(&peak_buffer, wr_buff, 0);
					write_to_buffer(&pk_freq_buffer, &fft_freqs[max_idx], 0);
					write_to_buffer(&pk_time_buffer, &time_h, 0);
					cand_flag &= 0x00;
					max_idx = 0;
					max_amp = 0;
				}
				else
					cand_flag |= 0x02;
			}
			else {
				max_idx = 0;
				max_amp = 0;
				cand_flag &= 0x00;
				min_amp = x[i] - MIN_PROM;
			}
		}
	}
	/*
	if (n_peaks == 0){
		wr_buff[0] = 0;
		*(uint32_t *)&wr_buff[1] = 0;
		*(uint32_t *)&wr_buff[5] = 0;
		write_to_buffer(&peak_buffer, wr_buff, 0);
	}
	*/
}

#ifdef WINDOWS_TESTING
void read_data_from_file(void)
{   
    char* filename = "C:\\Users\\bujak\\Desktop\\FER\\5_godina\\DIPLOMSKI_PROJEKT\\DILPOMSKI_RAD\\plant_AE_classification\\clustering\\comm_with_STM32\\input_data.txt";
	FILE *in_file = fopen(filename, "r");
    if (!in_file) {
        perror("fopen");
        exit(1);
    }

    struct stat sb;
    if (stat(filename, &sb) == -1) {
        perror("stat");
        exit(1);
    }

    char *file_contents = malloc(sb.st_size);

	int data_ind = -1;
    while (fscanf(in_file, "%[^\n ] ", file_contents) != EOF) {

		if (data_ind == -1)
		{
			char *pt;
			pt = strtok (file_contents,",");
			float32_t eps_read = atof(pt);
			pt = strtok (NULL, ",");
			float32_t Nmin_read = atof(pt);

			eps = eps_read;
			Nmin = Nmin_read;
		}
		else
		{
			char *pt;
			pt = strtok (file_contents,",");
			float feature_1 = atof(pt);
			pt = strtok (NULL, ",");
			float feature_2 = atof(pt);
			pt = strtok (NULL, ",");
			float feature_3 = atof(pt);

			data_feature1[data_ind] = feature_1;
			data_feature2[data_ind] = feature_2;
			data_feature3[data_ind] = feature_3;
		}
		data_ind++;
	}
    fclose(in_file);
}

void write_idx_to_file(void)
{   
    char* filename = "C:\\Users\\bujak\\Desktop\\FER\\5_godina\\DIPLOMSKI_PROJEKT\\DILPOMSKI_RAD\\plant_AE_classification\\clustering\\comm_with_STM32\\labels.txt";

	FILE* fptr = NULL; 
	fptr = fopen(filename, "w");

	if (fptr == NULL) 
	{
		perror(filename);
		exit(1); 
	};

    for (int i=0;i<dataSize;i++)
    {
         fprintf(fptr,"%d\n",clusterIndices[i]);
    }
    fclose(fptr);
}

void write_reach_to_file(void)
{   
    char* filename = "C:\\Users\\bujak\\Desktop\\FER\\5_godina\\DIPLOMSKI_PROJEKT\\DILPOMSKI_RAD\\plant_AE_classification\\clustering\\comm_with_STM32\\reach_dist.txt";

	FILE* fptr = NULL; 
	fptr = fopen(filename, "w");

	if (fptr == NULL) 
	{
		perror(filename);
		exit(1); 
	};

    for (int i=0;i<dataSize;i++)
    {
         fprintf(fptr,"%f\n",orderedReachDistList[i]);
    }
    fclose(fptr);
}

void read_emissions_from_file(void)
{   
    // char* filename = "C:\\Users\\bujak\\Desktop\\FER\\5_godina\\DIPLOMSKI_PROJEKT\\DILPOMSKI_RAD\\plant_AE_classification\\clustering\\comm_with_STM32\\emissions.txt";
    char* filename = "C:\\Users\\bujak\\Desktop\\FER\\5_godina\\DIPLOMSKI_PROJEKT\\DILPOMSKI_RAD\\plant_AE_classification\\clustering\\comm_with_STM32\\emiss_abs_fft.txt";
	FILE *in_file = fopen(filename, "r");
    if (!in_file) {
        perror("fopen");
        exit(1);
    }

    struct stat sb;
    if (stat(filename, &sb) == -1) {
        perror("stat");
        exit(1);
    }

    char *file_contents = malloc(sb.st_size);

	uint32_t  emiss_ind = 0;
    while (fscanf(in_file, "%[^\n ] ", file_contents) != EOF) {

		char *pt;
		pt = strtok (file_contents,",");
		float data_point = atof(pt);
		uint32_t data_point_ind = 0;
		emissions[emiss_ind][data_point_ind] = data_point;

		while(pt!=NULL)
		{
			data_point_ind++;
			pt = strtok (NULL, ",");
			data_point = atof(pt);
			emissions[emiss_ind][data_point_ind] = data_point;
		}
		emiss_ind++;
	}
    fclose(in_file);
}

#endif

#ifdef WINDOWS_TESTING
void sync_SD(task_s *task){};
#else
//This function syncs the files to SD
void sync_SD(task_s *task){
	FIL *file = (FIL*)task->args;
	volatile uint32_t *flag = task->flag;
	uint32_t mask = task->mask&(SD_SYNC_MEAS_FLAG|SD_SYNC_ENV_FLAG|SD_SYNC_FFT_FLAG|SD_SYNC_PEAK_FLAG|SD_SYNC_CLUST_FLAG);

	f_sync(file);
	*flag &= ~mask;
	
	queue_task(*task);
}
#endif

#ifdef WINDOWS_TESTING
static void init(void){};
#else
//This function initializes the MCU peripherals, opens the necessary files and sets up the interrupts
static void init(void){
	  /* MCU Configuration--------------------------------------------------------*/

  // Initialize all configured peripherals,the functions are defined in setup.c
  REG_GPIO_Init();

	MX_DMA_Init();
	REG_OCTOSPI_Init(event_dma_buffer[0]);

	REG_ADS_Init();
	
	REG_TIM2_Init();
	REG_LPTIM1_Init();
	REG_LPTIM2_Init();
	REG_BAT_ADC_Init();
	MX_SDMMC1_SD_Init();
	MX_FATFS_Init();
	REG_LPUART1_Init();
	REG_I2C1_Init(env_dma_buffer, (uint8_t *)&env_cmd);
	
	//mount the SD card
	
	fres = f_mount(&fs, "", 0);
	if(fres != FR_OK)
		Error_Handler();
	
	//open the files
	// TODO: Should open all new files that are added
	fres = f_open(&meas_file, "meas.bin", FA_OPEN_APPEND | FA_WRITE);
	if(fres != FR_OK)
		Error_Handler();
	f_sync(&meas_file);
	
	fres = f_open(&env_file, "env.bin", FA_OPEN_APPEND | FA_WRITE);
	if(fres != FR_OK)
		Error_Handler();
	f_sync(&env_file);
	
	
	f_open(&fft_file, "fft.bin", FA_OPEN_APPEND | FA_WRITE);
	if(fres != FR_OK)
		Error_Handler();
	f_sync(&fft_file);
	
	fres = f_open(&peak_file, "peaks.bin", FA_OPEN_APPEND | FA_WRITE);
	if(fres != FR_OK)
		Error_Handler();
	f_sync(&peak_file);
	
	fres = f_open(&clust_file, "clusts.bin", FA_OPEN_APPEND | FA_WRITE);
	if(fres != FR_OK)
		Error_Handler();
	f_sync(&clust_file);
	
	// TODO: When testing should open some files to read
	/*
	fres = f_open(&ev_file, "ev_file.bin", FA_READ);
	if(fres != FR_OK)
		Error_Handler();
	*/
	//Set up and enable interrupts
	//The ISR-s are defined in stm32l4xx_it.c
	

	
	HAL_NVIC_SetPriority(OCTOSPI1_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(OCTOSPI1_IRQn);
	OCTOSPI1->FCR = HAL_OSPI_FLAG_TE | HAL_OSPI_FLAG_TC;
	HAL_Delay(2);
	
	EXTI->PR1 = 0xFF;
	HAL_NVIC_SetPriority(EXTI0_IRQn, 2, 0);							
	HAL_NVIC_EnableIRQ(EXTI0_IRQn);

	
	HAL_NVIC_SetPriority(LPTIM1_IRQn,1,0);
	HAL_NVIC_EnableIRQ(LPTIM1_IRQn);
	LPTIM1->CR |= (0x01<<2);	//Start timer
	
	HAL_NVIC_SetPriority(LPTIM2_IRQn,4,0);
	HAL_NVIC_EnableIRQ(LPTIM2_IRQn);
	
	HAL_NVIC_SetPriority(I2C1_EV_IRQn, 3, 0);
	HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
	
	HAL_NVIC_SetPriority(ADC1_IRQn, 4, 0);
	HAL_NVIC_EnableIRQ(ADC1_IRQn);

//	status_flag |= STATUS_ADC_READY;
}
#endif

#ifdef WINDOWS_TESTING
void SystemClock_Config(void){};
#else
//This function sets up the system clock
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Configure the main internal regulator output voltage 
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 30;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV5;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV6;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	RCC_OscInitStruct.LSEState = RCC_LSE_ON;
	//RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
	__HAL_RCC_MSI_RANGE_CONFIG(RCC_MSIRANGE_11);		//RCC_MSIRANGE_5 -> 2MHz
	
  /** Initializes the CPU, AHB and APB busses clocks RCC_MSIRANGE_7
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV16;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_OSPI | RCC_PERIPHCLK_SDMMC1 | RCC_PERIPHCLK_LPTIM1 | 
																				RCC_PERIPHCLK_I2C1 | RCC_PERIPHCLK_LPTIM2 | RCC_PERIPHCLK_ADC | 
																				RCC_PERIPHCLK_LPUART1;
  PeriphClkInit.OspiClockSelection = RCC_OSPICLKSOURCE_PLL;	//40 MHz?
	PeriphClkInit.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_PLLP;
  PeriphClkInit.Lptim1ClockSelection = RCC_LPTIM1CLKSOURCE_LSE;
	PeriphClkInit.Lptim2ClockSelection = RCC_LPTIM2CLKSOURCE_LSE;
	PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_SYSCLK;
	PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_SYSCLK;
	PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_LSE;
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}
#endif
#ifdef WINDOWS_TESTING
void Error_Handler(void){while(1){}};
#else
void Error_Handler(void)
{
  while(1)
  {
		HAL_Delay(500);
//		HAL_GPIO_TogglePin(GPIOE, GPIO_PIN_9);
  }
}
#endif

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(char *file, uint32_t line)
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

